{
  "name": "Jackal",
  "tagline": "Jackal is a tool for visualizing fractals",
  "body": "# jackal\r\n\r\nJackal is a tool for visualizing fractal patterns.\r\n\r\n## Development\r\n\r\nOpen a terminal and type `lein repl` to start a Clojure REPL\r\n(interactive prompt).\r\n\r\nIn the REPL, type\r\n\r\n```clojure\r\n(run)\r\n(browser-repl)\r\n```\r\n\r\nThe call to `(run)` starts the Figwheel server at port 3449, which takes care of\r\nlive reloading ClojureScript code and CSS. Figwheel's server will also act as\r\nyour app server, so requests are correctly forwarded to the http-handler you\r\ndefine.\r\n\r\nRunning `(browser-repl)` starts the Figwheel ClojureScript REPL. Evaluating\r\nexpressions here will only work once you've loaded the page, so the browser can\r\nconnect to Figwheel.\r\n\r\nWhen you see the line `Successfully compiled \"resources/public/app.js\" in 21.36\r\nseconds.`, you're ready to go. Browse to `http://localhost:3449` and enjoy.\r\n\r\n**Attention: It is not needed to run `lein figwheel` separately. Instead we\r\nlaunch Figwheel directly from the REPL**\r\n\r\n## Trying it out\r\n\r\nIf all is well you now have a browser window saying 'Hello Chestnut',\r\nand a REPL prompt that looks like `cljs.user=>`.\r\n\r\nOpen `resources/public/css/style.css` and change some styling of the\r\nH1 element. Notice how it's updated instantly in the browser.\r\n\r\nOpen `src/cljs/jackal/core.cljs`, and change `dom/h1` to\r\n`dom/h2`. As soon as you save the file, your browser is updated.\r\n\r\nIn the REPL, type\r\n\r\n```\r\n(ns jackal.core)\r\n(swap! app-state assoc :text \"Interactivity FTW\")\r\n```\r\n\r\nNotice again how the browser updates.\r\n\r\n### Lighttable\r\n\r\nLighttable provides a tighter integration for live coding with an inline\r\nbrowser-tab. Rather than evaluating cljs on the command line with the Figwheel\r\nREPL, you can evaluate code and preview pages inside Lighttable.\r\n\r\nSteps: After running `(run)`, open a browser tab in Lighttable. Open a cljs file\r\nfrom within a project, go to the end of an s-expression and hit Cmd-ENT.\r\nLighttable will ask you which client to connect. Click 'Connect a client' and\r\nselect 'Browser'. Browse to [http://localhost:3449](http://localhost:3449)\r\n\r\nView LT's console to see a Chrome js console.\r\n\r\nHereafter, you can save a file and see changes or evaluate cljs code (without\r\nsaving a file).\r\n\r\n### Emacs/CIDER\r\n\r\nCIDER is able to start both a Clojure and a ClojureScript REPL simultaneously,\r\nso you can interact both with the browser, and with the server. The command to\r\ndo this is `M-x cider-jack-in-clojurescript`.\r\n\r\nWe need to tell CIDER how to start a browser-connected Figwheel REPL though,\r\notherwise it will use a JavaScript engine provided by the JVM, and you won't be\r\nable to interact with your running app.\r\n\r\nPut this in your Emacs configuration (`~/.emacs.d/init.el` or `~/.emacs`)\r\n\r\n``` emacs-lisp\r\n(setq cider-cljs-lein-repl\r\n      \"(do (user/run)\r\n           (user/browser-repl))\")\r\n```\r\n\r\nNow `M-x cider-jack-in-clojurescript` (shortcut: `C-c M-J`, that's a capital\r\n\"J\", so `Meta-Shift-j`), point your browser at `http://localhost:3449`, and\r\nyou're good to go.\r\n\r\n## Testing\r\n\r\nTo run the Clojure tests, use\r\n\r\n``` shell\r\nlein test\r\n```\r\n\r\nTo run the Clojurescript you use [doo](https://github.com/bensu/doo). This can\r\nrun your tests against a variety of JavaScript implementations, but in the\r\nbrowser and \"headless\". For example, to test with PhantomJS, use\r\n\r\n``` shell\r\nlein doo phantom\r\n```\r\n\r\n## Deploying to Heroku\r\n\r\nThis assumes you have a\r\n[Heroku account](https://signup.heroku.com/dc), have installed the\r\n[Heroku toolbelt](https://toolbelt.heroku.com/), and have done a\r\n`heroku login` before.\r\n\r\n``` sh\r\ngit init\r\ngit add -A\r\ngit commit\r\nheroku create\r\ngit push heroku master:master\r\nheroku open\r\n```\r\n\r\n## Running with Foreman\r\n\r\nHeroku uses [Foreman](http://ddollar.github.io/foreman/) to run your\r\napp, which uses the `Procfile` in your repository to figure out which\r\nserver command to run. Heroku also compiles and runs your code with a\r\nLeiningen \"production\" profile, instead of \"dev\". To locally simulate\r\nwhat Heroku does you can do:\r\n\r\n``` sh\r\nlein with-profile -dev,+production uberjar && foreman start\r\n```\r\n\r\nNow your app is running at\r\n[http://localhost:5000](http://localhost:5000) in production mode.\r\n## License\r\n\r\nDistributed under The MIT License (MIT)\r\n\r\n## Chestnut\r\n\r\nCreated with [Chestnut](http://plexus.github.io/chestnut/) 0.14.0 (66af6f40).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}